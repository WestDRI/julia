#+title: Introduction to Julia
#+slug: julia
#+date: 2020-03-03
#+place: 3h workshop at Simon Fraser University

#+OPTIONS: toc:2

#+BEGIN_center
#+ATTR_HTML: :width 200
[[/img/workinprogress.svg]]
#+END_center

This workshop is part of Simon Fraser University spring school:
#+BEGIN_center
#+ATTR_HTML: :alt radius
[[/img/sfu2020poster_no_padding.png]]
#+END_center

#+HTML: <br>
#+BEGIN_sticker
[[https://www.eventbrite.ca/e/research-computing-workshops-simon-fraser-university-registration-88799572913][Register for free workshop]]
#+END_sticker

* Abstract

#+BEGIN_definition
#+BEGIN_quote
Why would I want to learn a new language? I already know R/python.
#+END_quote

R and python are interpreted languages: the code is executed directly, without prior-compilation. This is extremely convenient: it is what allows you to run code in an interactive shell. The price to pay is low performance: R and python are simply not good at handling large amounts of data. To overcome this limitation, users often turn to C or C++ for the most computation-intensive parts of their analyses. These are compiled—and extremely efficient—languages, but the need to use multiple languages and the non-interactive nature of compiled languages make this approach tedious.

Julia uses just-in-time (JIT) compilation: the code is compiled at run time. This combines the interactive advantage of interpreted languages with the efficiency of compiled ones. Basically, it feels like running R or python, while it is almost as fast as C. This makes Julia particularly well suited for big data analyses, machine learning, or heavy modelling.

In addition, multiple dispatch (generic functions with multiple methods depending on the types of all the arguments) is at the very core of Julia. This is extremly convenient, cutting on conditionals and repetitions, and allowing for easy extensibility without having to rewrite code.

Finally, Julia shines by its extremely clean and concise syntax. This last feature makes it easy to learn and really enjoyable to use.

In this workshop, which does not require any prior experience in Julia (experience in another language—e.g. R or python—would be best), we will go over the basics of Julia's syntax and package system; then we will push the performance aspect further by looking at how Julia can make use of clusters for large scale parallel computing.
#+END_definition

* Requirements

** A terminal emulator and an SSH client for remote access to clusters

Windows: install the free Home Edition of [[https://mobaxterm.mobatek.net/download.html][MobaXTerm]]
MacOS: Terminal and SSH are pre-installed
Linux: install [[https://www.openssh.com/][OpenSSH]]
- The current [[https://julialang.org/downloads/][Julia stable release]]

* Intro to Julia

** Background

*** Brief history

A very interesting [[https://graydon2.dreamwidth.org/189377.html][post]], in which [[https://www.rust-lang.org/][Rust]] developer Graydon Hoare places Julia in a historical context of programming languages.

*** Why another language?

**** Just-in-time (JIT) compilation

[[https://en.wikipedia.org/wiki/Just-in-time_compilation][Just-in-time compilation]] 

***** Compiled languages

[[/img/compiled_language.png]]

Source code is human-readable, usually in plain text. That's the highest level.\\
Machine code is the lowest level.

***** Interpreted languages

[[/img/interpreted_language.png]]

The source code can facultatively be bytecompiled into non human-readable, more compact, lower level bytecode which is read by the interpreter more efficiently.

**** Multiple dispatch

opt-in type checking

** Getting started

*** Where to find resources

[[https://julialang.org/][Julia's website]]

**** Documentation

- The official Julia [[https://docs.julialang.org/en/v1/][manual]]

- Online [[https://julialang.org/learning/][training]] material

- [[https://www.youtube.com/user/JuliaLanguage][YouTube]] channel

**** Getting help

- Discourse [[https://discourse.julialang.org/][forum]]

- [[https://stackoverflow.com/tags/julia][[julia] ]]tag on Stack Overflow

- [[https://app.slack.com/client/T68168MUP/C67910KEH][Slack]] team (you need to agree to the community code of conduct at slackinvite.julialang.org to receive an invitation)

- [[https://twitter.com/search?q=%23julialang][#julialang]] hashtag on Twitter

- [[https://www.reddit.com/r/Julia/][Subreddit]]

- [[https://gitter.im/JuliaLang/julia][Gitter]] channel

- [[https://webchat.freenode.net/#julia][#julia]] IRC channel on Freenode

*** Nice ways to run Julia

- Emacs through the Emacs [[https://ess.r-project.org/][ESS]] or [[https://github.com/JuliaEditorSupport/julia-emacs][julia-emacs]] packages. You can also run Jupyter notebooks through the [[http://millejoh.github.io/emacs-ipython-notebook/][Emacs IPython Notebook (EIN)]] package

- The [[https://junolab.org/][Juno]] IDE

- [[https://jupyter.org/][Jupyter notebooks]]

** Syntax

*** 3 REPL modes

- Julian
- Pkg
- help

** Packages

Conveniently, all packages are on GitHub and they can easily be searched [[https://pkg.julialang.org/docs/][here]].

* Hands-on

using Distributed
nprocs()
nworkers()

** Working with Julia locally


** Working with Julia on the cluster

Now that we have a running script, let's submit a job to the cluster.

*** Log in to the cluster

Open a terminal emulator (also called shell or command line interface).

/Windows users, launch [[https://mobaxterm.mobatek.net/][MobaXTerm]].\\
MacOS users, launch the program "Terminal"./

#+BEGIN_src sh
ssh userxxx@cassiopeia.c3.ca

# enter password
#+END_src

You are now in our training cluster.

*** Access Julia

This is done through the [[https://docs.computecanada.ca/wiki/Utiliser_des_modules/en][module]] command.

#+BEGIN_src sh
# get help on the module command
module help
module --help
module -h

# list modules that are already loaded
module list

# see which modules are available for Julia
module spider julia

# see how to load julia 1.3
module spider julia/1.3.0

# load julia 1.3 with the required gcc module first
# (the order is important)
module load gcc/7.3.0 julia/1.3.0

# you can see that we now have Julia loaded
module list
#+END_src

source /project/shared/syncHPC/startJulia.sh
julia


module load gcc/7.3.0 julia/1.3.0
export JULIA_DEPOT_PATH="julia:@v#.#:@stdlib:/project/shared/bio"
export JULIA_LOAD_PATH=$JULIA_LOAD_PATH:/project/shared/bio



*** Write Julia script which can be run from the command line

#+BEGIN_export html
Save your script in the file <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">julia_script.jl</span>.
#+END_export

#+BEGIN_src julia
# install necessary packages
import Pkg
Pkg.add(["", ""])


#+END_src

*** Job script

#+BEGIN_export html
Save your Slurm job script in the file <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">job_script.sh</span>.
#+END_export

#+BEGIN_src sh
#!/bin/bash
#SBATCH --job-name=julia		# job name
#SBATCH --time=00:01:00			# max walltime
#SBATCH --mem=100M				# max memory
#SBATCH --output=julia%j.out	# file name for the output
#SBATCH --error=julia%j.err		# file name for errors
# %j gets replaced with the job number

# load necessary modules
module load gcc/7.3.0 julia/1.3.0

# run our Julia script
julia julia_script.jl
#+END_src

We submit our job with:

#+BEGIN_src sh
sbatch job_script.sh
#+END_src

And we can check its status with:

#+BEGIN_src sh
sq
#+END_src



