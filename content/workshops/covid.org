#+title: Covid-19 in Julia
#+slug: covid

#+OPTIONS: toc:2

#+BEGIN_center
#+ATTR_HTML: :width 200
[[/img/workinprogress.svg]]
#+END_center

**** /Requirements/

#+BEGIN_box
For this workshop, you will need:

*1 - The current [[https://julialang.org/downloads/][Julia stable release]]*

Installation instructions can be found [[https://julialang.org/downloads/platform/][here]].

*2 - The packages: [[https://github.com/JuliaData/CSV.jl][CSV]], [[https://github.com/JuliaData/DataFrames.jl][DataFrames]], [[https://github.com/JuliaStats/TimeSeries.jl][TimeSeries]], [[https://github.com/JuliaPlots/Plots.jl][Plots]]*

#+BEGIN_export html
Packages can be installed with <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">] add &lt;package&gt;</span>
#+END_export

*3 - Covid-19 data from the [[https://github.com/CSSEGISandData/COVID-19][Johns Hopkins University CSSE repository]]*

#+BEGIN_export html
Clone (<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">git clone &lt;repo url&gt;</span>) or download and unzip the repository.<br><br>
#+END_export
#+END_box

**** Load packages

Choose the [[https://gr-framework.org/][GR framework]] as a backend for Plots.

#+BEGIN_src julia
using CSV
using DataFrames
using Dates          # from the standard Julia library
using TimeSeries
using NamedArrays
using Plots
gr()
#+END_src

* Data until March 22, 2020

The files in the [[https://github.com/CSSEGISandData/COVID-19][Johns Hopkins University CSSE repository]] have changed over time.\\
In this workshop, we will use 2 sets of files:

- a first set from January 22, 2020 until March 22, 2020
- a second set from January 22, 2020 to the present

Both sets contain data on confirmed and dead cases for world countries and in some cases their subregions (provinces, states, etc. which I will globally here call "provinces").

The first set also contains numbers of recovered cases which allow to calculate numbers of currently ill persons (of course, keep in mind that all these data represent various degrees of underestimation and are flawed in many ways, amongst which are varying levels of testing efforts both geographically and over time, under-reporting, etc).

The second set does not contain recovered cases (many overwhelmed countries stopped monitoring this at some point).

We will play with the first set together and you will then try to play with the second set on your own.

** Load the data

/If you did not clone or download and unzip the Covid-19 data repository in your working directory, adapt the path consequently./

#+BEGIN_src julia
#= create a variable with the path we are interested in;
this makes the code below a bit shorter =#
dir = "COVID-19/csse_covid_19_data/csse_covid_19_time_series"

# create a list of the full paths of all the files in dir
list = joinpath.(relpath(dir), readdir(dir))

#= read in the 3 csv files with confirmed, dead, and recovered numbers
corresponding to the first set of data (until March 22, 2020) =#
dat = DataFrame.(CSV.File.(list[collect(2:4)]))
#+END_src

#+BEGIN_export html
We now have a one-dimensional array of 3 DataFrames called <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">dat</span>.
#+END_export

** Transform data into long format

#+BEGIN_src julia
# rename some variables to easier names
DataFrames.rename!.(dat, Dict.(1 => Symbol("province"),
                               2 => Symbol("country")))

# create a one-dimensional array of strings
var = ["total", "dead", "recovered"]

#= transform the data into long format in a vectorized fashion 
using both our one-dimensional arrays of 3 elements =#
datlong = map((x, y) -> stack(x, Not(collect(1:4)),
                              variable_name = Symbol("date"),
                    value_name = Symbol("$y")),
     dat, var)
#+END_src

#+BEGIN_export html
We now have a one-dimensional array of 3 DataFrames in long format called <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">datlong</span>.
#+END_export

#+BEGIN_src julia
# join all elements of this array into a single DataFrame
all = join(datlong[1], datlong[2], datlong[3],
           on = [:date, :country, :province, :Lat, :Long])

# get rid of "Lat" and "Long" and re-order the columns
select!(all, [4, 3, 1, 2, 7, 8])

#= turn the year from 2 digits to 4 digits using regular expression
(in a vectorised fashion by braodcasting with the dot notation);
then turn these values into strings, and finally into dates =#
all.date = Date.(replace.(string.(all[:, 3]),
                          r"(.*)(..)$" => s"\g<1>20\2"), "m/dd/yy");

#= replace the missing values by the string "NA"
(these are not real missing values, but rather non applicable ones) =#
replace!(all.province, missing => "NA");
#+END_src

#+BEGIN_export html
We now have a single DataFrame called <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">all</span>, in long format, with the variables <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">confirmed</span>, <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">dead</span>, <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">recovered</span>, and <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">ill</span>.
#+END_export

Calculate the number of currently ill individuals (again, in a vectorized fashion, by broadcasting with the dot notation):

#+BEGIN_src julia
all.current = all.total .- all.dead .- all.recovered;
#+END_src

** World summary

To make a single plot with world totals of confirmed, dead, recovered, and ill cases, we want the sums of these variables for each day. We do this by grouping the data by date:

#+BEGIN_src julia
world = by(all, :date,
           total = :total => sum,
           dead = :dead => sum,
           recovered = :recovered => sum,
           current = :current => sum)
#+END_src

#+BEGIN_export html
Now we can plot our new variable <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">world</span>.<br>

As our data is a time series, we need to transform it to a TimeArray thanks to the <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">TimeArray()</span> function from the TimeSeries package.
#+END_export

#+BEGIN_src julia
plot(TimeArray(world, timestamp = :date),
     title = "World",
     legend = :outertopright,
     widen = :false)
#+END_src

#+ATTR_HTML: :alt plot :title Global confirmed, dead, recovered, and current up to March 22, 2020
[[/plot/workshop/covid/world1.png]]

#+BEGIN_export html
<div class="figcom">
  Data until March 22, 2020
</div>
#+END_export

** Countries/provinces summary

Now, we want to group the data by country:

#+BEGIN_src julia
countries = groupby(all, :country)
#+END_src

We also need to know how the authors of the dataset decided to label the various countries and their subregions.

For example, if you want to see what the data looks like for France, Canada, and India, you can run:

#+BEGIN_src julia
countries[findall(x -> "France" in x, keys(countries))]
countries[findall(x -> "Canada" in x, keys(countries))]
countries[findall(x -> "India" in x, keys(countries))]
#+END_src

Then you need to subset the data for the countries or provinces you are interested in.

Here are some examples:

#+BEGIN_src julia
# countries for which there are data for several provinces
canada = all[all[:, :country] .== "Canada", :]
us = all[all[:, :country] .== "US", :]
china = all[all[:, :country] .== "China", :]

# countries with no province data
skorea = all[all[:, :country] .== "Korea, South", :]
taiwan = all[all[:, :country] .== "Taiwan*", :]
singapore = all[all[:, :country] .== "Singapore", :]
italy = all[all[:, :country] .== "Italy", :]
spain = all[all[:, :country] .== "Spain", :]

#= countries wich have subregions spread widely in the world;
here, I took the arbitrary decision to only look at the main subregions =#
france = all[all[:, :province] .== "France", :]
uk = all[all[:, :province] .== "United Kingdom", :]

# provinces
bc = all[all[:, :province] .== "British Columbia", :]
ny = all[all[:, :province] .== "New York", :]
#+END_src

Calculate the totals for Canada, US, and China which all have data for subregions:

#+BEGIN_src julia
canada, us, china = by.([canada, us, china], :date,
                        total = :total => sum,
                        dead = :dead => sum,
                        recovered = :recovered => sum,
                        current = :current => sum)
#+END_src

#+BEGIN_src julia
loclist1 = [canada, us, china]
loctitles1 = ["Canada", "US", "China"]

pcanada, pus, pchina =
    map((x, y) -> plot(TimeArray(x, timestamp = :date),
                       title = "$y", legend = :outertopright,
                       widen = :false, dpi = :300),
        loclist1, loctitles1)
#+END_src

#+BEGIN_src julia
loclist2 = [france, bc, ny, taiwan, skorea, singapore, spain, italy, uk]
loctitles2 = ["France", "BC", "NY", "Taiwan", "South Korea",
              "Singapore", "Spain", "Italy", "UK"]

pfrance, pbc, pny, ptaiwan, pskorea,
psingapore, pspain, pitaly, puk =
    map((x, y) -> plot(TimeArray(select(x, Not([:country, :province])),
                                 timestamp = :date),
                       title = "$y", legend = :outertopright,
                       widen = :false, dpi = :300),
        loclist2, loctitles2)
#+END_src

Now, let's plot a few countries/provinces:

*** North America

#+BEGIN_src julia
plot(pcanada, pbc, pus, pny,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

#+ATTR_HTML: :alt plot :title Confirmed, dead, recovered, and current in some North American countries/provinces until March 22, 2020
[[/plot/workshop/covid/northamerica1.png]]

#+BEGIN_export html
<div class="figcom">
  Data until March 22, 2020
</div>
#+END_export

*** Asia

#+BEGIN_src julia
plot(pchina, ptaiwan, pskorea, psingapore,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

#+ATTR_HTML: :alt plot :title Confirmed, dead, recovered, and current in some Asian countries until March 22, 2020
[[/plot/workshop/covid/asia1.png]]

#+BEGIN_export html
<div class="figcom">
  Data until March 22, 2020
</div>
#+END_export

*** Europe

#+BEGIN_src julia
plot(pfrance, pspain, pitaly, puk,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

#+ATTR_HTML: :alt plot :title Confirmed, dead, recovered, and current in some European countries until March 22, 2020
[[/plot/workshop/covid/europe1.png]]

#+BEGIN_export html
<div class="figcom">
  Data until March 22, 2020
</div>
#+END_export

* Data up to the present

** World/countries/provinces summary graphs

#+BEGIN_challenge
#+BEGIN_export html
<span style="color: #e10070">Your turn:</span><br>
Write the code to create an up-to-date graph for the world using the files:<br>
<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; border-radius: 5%; border: 0.5pt solid #d9d9d9; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); color: #000000">time_series_covid19_confirmed_global.csv</span> and <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.2rem; border-radius: 5%; border: 0.5pt solid #d9d9d9; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); color: #000000">time_series_covid19_deaths_global.csv</span>.
#+END_export
#+END_challenge

Here is the result:

#+ATTR_HTML: :alt plot :title Global confirmed and dead
[[/plot/workshop/covid/world.png]]

{{< updated >}}

#+BEGIN_challenge
#+BEGIN_export html
<span style="color: #e10070">Your turn:</span><br>
Create up-to-date graphs for the countries and/or provinces of your choice.
#+END_export
#+END_challenge

Here are a few possible results:

#+ATTR_HTML: :alt plot :title Confirmed and dead for Italy, Spain, the US, and Canada
[[/plot/workshop/covid/4countries.png]]

{{< updated >}}

* Comments & questions
