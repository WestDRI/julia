#+title: Parallel computing in Julia
#+description: Zoom
#+colordes: #e86e0a
#+slug: 10_jl_parallel
#+weight: 10

#+BEGIN_simplebox
*Zoom session 3 â€” part 1*

/Time:/ {{<m>}}3 pm Pacific Time. \\
/Topic:/ {{<m>}}In this session, we will solve [[https://en.wikipedia.org/wiki/N-body_problem][the n-body problem]] in Julia.
#+END_simplebox

* Multi-threading

** Launching Julia on multiple threads

To use Julia on multiple threads, you need to set the {{<b>}}JULIA_NUM_THREADS{{</b>}} environment variable.

This can be done by running (in the terminal, not in Julia):

#+BEGIN_src sh
$ export JULIA_NUM_THREADS=n      # n is the number of threads you want to use
#+END_src

Or by launching Julia with (again, in the terminal):

#+BEGIN_src sh
$ JULIA_NUM_THREADS=n julia
#+END_src

For example, to launch Julia on 4 threads, you can run:

#+BEGIN_src sh
$ JULIA_NUM_THREADS=4 julia
#+END_src

/Note 1:/

The Juno IDE automatically launches Julia on all your available threads.

/Note 2:/

Windows users can also set this environment variable with CMD with:

#+BEGIN_src sh
set JULIA_NUM_THREADS=n
#+END_src

or with Powershell with:

#+BEGIN_src sh
$env:JULIA_NUM_THREADS=n
#+END_src

*** How do you know how many threads are available on your machine?

A lot of laptops around have 4 threads (2 CPU, each with 2 threads). Utilities such as [[https://github.com/hishamhm/htop][htop]] allow you to visualize the working threads.

**** Linux

From a terminal:

#+BEGIN_src sh
$ nproc
#+END_src

**** Windows

Go to {{<b>}}System Information{{</b>}}. This will show you the {{<b>}}System Summary{{</b>}} in which you can see a description of your {{<b>}}Processor{{</b>}}.

**** MacOS

From Terminal:

#+BEGIN_src sh
sysctl -n hw.ncpu
#+END_src

** Using multiple threads

Multi-threading is supported by the {{<b>}}Base.Threads{{</b>}} interface (part of the {{<b>}}Base{{</b>}} module of Julia) which contains a number of functions and macros. Below are the most important ones.

*** How do you know how many threads you are using in your Julia session?

To see how many threads you are using, you can run (in the Julia REPL):

#+BEGIN_src julia
julia> Threads.nthreads()
#+END_src

/Note: if you could not determine how many threads you have on your machine with the methods above, you can try to launch Julia on a number of threads larger than what you can possibly have (e.g. 10) and run this command. Julia will be launched on all your available threads and this command will tell you how many that is./

To get the ID of the current thread, you can run:

#+BEGIN_src julia
julia> Threads.threadid()
#+END_src

*** For loop on multiple threads

This is done thanks to the {{<c>}}Threads.@threads{{</c>}} macro:

#+BEGIN_src julia
julia> Threads.@threads for i = 1:10
           println("i = $i on thread $(Threads.threadid())")
       end
#+END_src

*** Multi-threading outside of the context of loops

Here, you want to use the {{<c>}}Threads.@spawn{{</c>}} macro. This feature is currently experimental and not documented in the Julia manual, but an example is given in [[https://julialang.org/blog/2019/07/multithreading/][this Julia blog post]].

* Distributed computing

** Launching several Julia processes

Julia supports distributed computing thanks to the module {{<b>}}Distributed{{</b>}} from its standard library.

There are two ways to launch several Julia processes (called "workers"):

*** Launch Julia on n workers

Julia can be started with the {{<c>}}-p{{</c>}} flag followed by the number of workers by running (in a terminal):

#+BEGIN_src sh
julia -p n
#+END_src

This launches {{<b>}}n{{</b>}} workers, available for parallel computations, in addition to the process running the interactive prompt (so there are {{<b>}}n + 1{{</b>}} Julia processes in total).

The module {{<b>}}Distributed{{</b>}} is needed whenever you want to use several workers, but the {{<c>}}-p{{</c>}} flag loads it automatically.

/Example:/

#+BEGIN_src sh
julia -p 4
#+END_src

Within Julia, you can see how many workers are running with:

#+BEGIN_src julia
nworkers()
#+END_src

The total number of processes can be seen with:

#+BEGIN_src julia
nprocs()
#+END_src

*** Start workers from within a Julia session

Alternatively, workers can be started from within a Julia session. In this case, you need to load the module {{<b>}}Distributed{{</b>}} explicitly:

#+BEGIN_src julia
using Distributed
#+END_src

To launch {{<b>}}n{{</b>}} workers:

#+BEGIN_src julia
addprocs(n)
#+END_src

/Example:/

#+BEGIN_src julia
addprocs(4)
#+END_src

** Managing workers

To list all the worker process identifiers:

#+BEGIN_src julia
workers()
#+END_src

/Note:/ {{<s>}}The process running the Julia prompt has id {{<b>}}1{{</b>}}.

To kill a worker:

#+BEGIN_src julia
rmprocs(<pid>)
#+END_src

where {{<c>}}&lt;pid&gt;{{</c>}} is the process identifier of the worker you want to kill (you can kill several workers by providing a list of pids).

** Using workers

There are a number of [[https://docs.julialang.org/en/v1/manual/metaprogramming/#man-macros-1][macros]] that are very convenient here:

- To execute an expression on all processes, there is {{<c>}}@everywhere{{</c>}}

For instance, if your parallel code requires a module or an external package to run, you need to load that module or package with {{<c>}}@everywhere{{</c>}}:

#+BEGIN_src julia
@everywhere using DataFrames
#+END_src

If the parallel code requires a script to run:

#+BEGIN_src julia
@everywhere include("script.jl")
#+END_src

If it requires a function that you are defining, you need to define it on all the workers:

#+BEGIN_src julia
@everywhere function <name>(<arguments>)
    <body>
end
#+END_src

- To assign a task to a particular worker, you use {{<c>}}@spawnat{{</c>}}

The first argument indicates the process id, the second argument is the expression that should be evaluated.

#+BEGIN_src julia
@spawnat <pid> <expression>
#+END_src

{{<c>}}@spawnat{{</c>}} returns of {{<b>}}Future{{</b>}}: the placeholder for a computation of unknown status and time. The function {{<c>}}fetch{{</c>}} waits for a {{<b>}}Future{{</b>}} to complete and returns the result of the computation.

/Example:/

The function {{<c>}}myid{{</c>}} gives the id of the current process. As I mentioned earlier, the process running the interactive Julia prompt has the pid {{<b>}}1{{</b>}}. So {{<c>}}myid(){{</c>}} normally returns {{<c>}}1{{</c>}}.

But we can "spawn" {{<c>}}myid{{</c>}} on one of the worker, for instance the first worker (so pid {{<b>}}2{{</b>}}):

#+BEGIN_src julia
@spawnat 2 myid()
#+END_src

As you can see, we get a {{<b>}}Future{{</b>}} as a result. But if we pass it through {{<c>}}fetch{{</c>}}, we get the result of {{<c>}}myid{{</c>}} ran on the worker with pid {{<b>}}2{{</b>}}:

#+BEGIN_src julia
fetch(@spawnat 2 myid())
#+END_src

If you want tasks to be assigned to any worker automatically, you can pass the symbol {{<c>}}:any{{</c>}} to {{<c>}}@spawnat{{</c>}} instead of the worker id:

#+BEGIN_src julia
@spawnat :any myid()
#+END_src

To get the result:

#+BEGIN_src julia
fetch(@spawnat :any myid())
#+END_src

If you run this multiple times, you will see that {{<c>}}myid{{</c>}} is run on any of your available workers. This will however never return {{<c>}}1{{</c>}}, /except/ when you only have one running Julia process (in that case, the process running the prompt is considered a worker).

** Data too large to fit in the memory of one machine

There is a package for this: [[https://github.com/JuliaParallel/DistributedArrays.jl][DistributedArrays]].

* Comments & questions
