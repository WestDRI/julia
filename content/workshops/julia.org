#+title: Introduction to Julia
#+slug: julia
#+date: 2020-03-03
#+place: 3h workshop at Simon Fraser University

#+OPTIONS: toc:2

#+BEGIN_center
#+ATTR_HTML: :width 200
[[/img/workinprogress.svg]]
#+END_center

This workshop is part of Simon Fraser University spring school:
#+BEGIN_center
#+ATTR_HTML: :alt radius
[[/img/sfu2020poster_no_padding.png]]
#+END_center

#+HTML: <br>
#+BEGIN_sticker
[[https://www.eventbrite.ca/e/research-computing-workshops-simon-fraser-university-registration-88799572913][Register for free workshop]]
#+END_sticker

* Abstract

#+BEGIN_definition
#+BEGIN_quote
Why would I want to learn a new language? I already know R/python.
#+END_quote

R and python are interpreted languages: the code is executed directly, without prior-compilation. This is extremely convenient: it is what allows you to run code in an interactive shell. The price to pay is low performance: R and python are simply not good at handling large amounts of data. To overcome this limitation, users often turn to C or C++ for the most computation-intensive parts of their analyses. These are compiled—and extremely efficient—languages, but the need to use multiple languages and the non-interactive nature of compiled languages make this approach tedious.

Julia uses just-in-time (JIT) compilation: the code is compiled at run time. This combines the interactive advantage of interpreted languages with the efficiency of compiled ones. Basically, it feels like running R or python, while it is almost as fast as C. This makes Julia particularly well suited for big data analyses, machine learning, or heavy modelling.

In addition, multiple dispatch (generic functions with multiple methods depending on the types of all the arguments) is at the very core of Julia. This is extremly convenient, cutting on conditionals and repetitions, and allowing for easy extensibility without having to rewrite code.

Finally, Julia shines by its extremely clean and concise syntax. This last feature makes it easy to learn and really enjoyable to use.

In this workshop, which does not require any prior experience in Julia (experience in another language—e.g. R or python—would be best), we will go over the basics of Julia's syntax and package system; then we will push the performance aspect further by looking at how Julia can make use of clusters for large scale parallel computing.
#+END_definition

* Software requirements

#+BEGIN_box
For this workshop, you will need:

*1 - A terminal emulator and an SSH client for remote access to clusters*

/Windows:/ \\
Install the free Home Edition of [[https://mobaxterm.mobatek.net/download.html][MobaXTerm]].

/MacOS:/ \\
Terminal and SSH are pre-installed.

/Linux:/ \\
You can use xterm or the terminal emulator of your choice.\\
If SSH does not come bundled with your distribution, install [[https://www.openssh.com/][OpenSSH]].

*2 - The current [[https://julialang.org/downloads/][Julia stable release]]*

*3 - A good text editor or the Julia IDE*

You will need a capable text editor (e.g. Emacs, Vim, Visual Studio Code, Sublime, Nano, Atom, Notepad++).\\
If you would rather play in the Julia IDE, you can find the installation instructions [[http://docs.junolab.org/latest/man/installation][here]].
#+END_box

* Introducing Julia

** Background

*** Brief history

Started in 2009 by Jeff Bezanson, [[https://en.wikipedia.org/wiki/Stefan_Karpinski][Stefan Karpinski]], [[https://en.wikipedia.org/wiki/Viral_B._Shah][Viral B. Shah]], and [[https://en.wikipedia.org/wiki/Alan_Edelman][Alan Edelman]], the general-purpose programming language Julia was launched in 2012 as free and open source software. Version 1.0 was released in 2018.

[[https://www.rust-lang.org/][Rust]] developer Graydon Hoare wrote an interesting [[https://graydon2.dreamwidth.org/189377.html][post]] which places Julia in a historical context of programming languages.

*** Why another language?

**** JIT

Computer languages mostly fall into two categories: *compiled languages* and *interpreted languages*.

***** Compiled languages

Compiled languages require two steps:

- in a first step the code you write in a human-readable format (the source code, usually in plain text) gets compiled into machine code

- it is then this machine code that is used to process your data

So you write a script, compile it, then use it.

[[/img/compiled_language.png]]

Because machine code is a lot easier to process by computers, compiled languages are fast. The two step process however makes prototyping new code less practical, these languages are hard to learn, and debugging compilation errors can be challenging.

Examples of compiled languages include C, C++, Fortran, Go, and Haskell.

***** Interpreted languages

Interpreted languages are executed directly which has many advantages such as dynamic typing and direct feed-back from the code and they are easy to learn, but this comes at the cost of efficiency. The source code can facultatively be bytecompiled into non human-readable, more compact, lower level bytecode which is read by the interpreter more efficiently.

[[/img/interpreted_language.png]]

Examples of interpreted languages include R, Python, Perl, and JavaScript.

***** JIT compiled languages

Julia uses [[https://en.wikipedia.org/wiki/Just-in-time_compilation][just-in-time compilation]] or JIT based on [[https://en.wikipedia.org/wiki/LLVM][LLVM]]: the source code is compiled at run time. This combines the flexibility of interpretation with the speed of compilation, bringing speed to an interactive language. It also allows for dynamic recompilation, continuous weighing of gains and costs of the compilation of parts of the code, and other on the fly optimizations.

Of course, there are costs here too. They come in the form of overhead time to compile code the first time it is run and increased memory usage.

**** Multiple dispatch

opt-in type checking

** Getting started

*** Where to find resources

The main place to look for resources is the Julia [[https://julialang.org/][website]].

**** Documentation

- The official Julia [[https://docs.julialang.org/en/v1/][manual]]

- Online [[https://julialang.org/learning/][training]] material

- The Julia [[https://www.youtube.com/user/JuliaLanguage][YouTube]] channel

- A [[https://www.juliabloggers.com/][blog]] aggregator for Julia

**** Getting help

- Discourse [[https://discourse.julialang.org/][forum]]

- [[https://stackoverflow.com/tags/julia][[julia] ]]tag on Stack Overflow

- [[https://app.slack.com/client/T68168MUP/C67910KEH][Slack]] team (you need to agree to the community code of conduct at slackinvite.julialang.org to receive an invitation)

- [[https://twitter.com/search?q=%23julialang][#julialang]] hashtag on Twitter

- [[https://www.reddit.com/r/Julia/][Subreddit]]

- [[https://gitter.im/JuliaLang/julia][Gitter]] channel

- [[https://webchat.freenode.net/#julia][#julia]] IRC channel on Freenode

*** Nice ways to run Julia

Copying and pasting code from a script to the Julia REPL works, but there are nicer ways to integrate the two.

Here are a few:

**** Emacs

- through the [[https://github.com/JuliaEditorSupport/julia-emacs][julia-emacs]] and [[https://github.com/tpapp/julia-repl][julia-repl]] packages
- through the [[https://github.com/emacs-ess/ESS][ESS]] package
- through the [[http://millejoh.github.io/emacs-ipython-notebook/][Emacs IPython Notebook]] package if you want to access Jupyter notebooks in Emacs

**** Juno

[[https://junolab.org/][Juno]] is an IDE for Julia built on [[https://atom.io/][Atom]].

**** Jupyter

[[https://jupyter.org/][Project Jupyter]] allows to create interactive programming documents through its web-based JupyterLab environment and its Jupyter Notebook.

** Packages

All packages are on GitHub and can easily be searched [[https://pkg.julialang.org/docs/][here]].

* Hands-on

** Working with Julia locally

While we will be interacting with Julia through the REPL (read–eval–print loop: the interactive Julia shell) to develop and test our code, we want to save it in a script for future use and to submit to the cluster.

#+BEGIN_export html
Julia scripts are text files with the extension <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">.jl</span>.
#+END_export

#+BEGIN_export html
Create a folder called <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">julia_workshop</span> somewhere in your system and create a file <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">julia_script.jl</span> in it.
#+END_export

*** Keybindings

In the REPL, you can use standard command line keybindings:

#+BEGIN_example
C-c		cancel
C-d		quit
C-l		clear console

C-u		kill from the start of line
C-k		kill until the end of line

C-a		go to start of line
C-e		go to end of line

C-f		move forward one character
C-b		move backward one character

M-f		move forward one word
M-b		move backward one word

C-d		delete forward one character
C-h		delete backward one character

M-d		delete forward one word
M-Backspace	delete backward one word

C-p		previous command
C-n		next command

C-r		backward search
C-s		forward search
#+END_example

In addition, there are 4 REPL modes:

#+BEGIN_export html
<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #339933"><b>julia></b></span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The main mode in which you will be running your code.<br><br>
#+END_export

#+BEGIN_export html
<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #dab314"><b>help?></b></span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A mode to easily access documentation.<br><br>
#+END_export

#+BEGIN_export html
<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #b30000"><b>shell></b></span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A mode in which you can run bash commands from within Julia.<br><br>
#+END_export

#+BEGIN_export html
<span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #2e5cb8"><b>(env) pkg></b></span> &nbsp;&nbsp; A mode to easily perform actions on packages with Julia package manager.<br><br>
Enter the various modes with <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">?</span>&nbsp; <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">;</span>&nbsp; <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">]</span> and go back to the regular mode with the <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">Backspace</span> key.
#+END_export

*** First few commands

Run a couple of commands in the REPL:

#+BEGIN_src julia

#+END_src

*** Comments

#+BEGIN_src julia
# Single line comment

#=
Comments can
also contain
multiple lines
=#

x = 2;    # And they can be added at the end of lines
#+END_src

** Working with Julia on the cluster

Now that we have a running script, let's submit a job to the cluster.

*** Log in to the cluster

Open a terminal emulator.

/Windows users, launch [[https://mobaxterm.mobatek.net/][MobaXTerm]]./ \\
/MacOS users, launch Terminal./ \\
/Linux users, launch xterm or the terminal emulator of your choice./

#+BEGIN_src sh
ssh userxxx@cassiopeia.c3.ca

# enter password
#+END_src

You are now in our training cluster.

*** Copy your Julia script to the training cluster

#+BEGIN_export html
We will create a <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">julia_workshop</span> directory in <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">~/scratch</span>, then copy our julia script in it.
#+END_export

#+BEGIN_src sh
mkdir ~/scratch/julia_job
#+END_src

Open a new terminal window and from your local terminal (make sure that you are not on the remote terminal by looking at the bash prompt) run:

#+BEGIN_src sh
scp /path/to/your/local/julia_script.jl userxxx@cassiopeia.c3.ca:scratch/julia_job

# enter password
#+END_src

*** Access Julia

This is done with the [[https://github.com/TACC/Lmod][Lmod]] tool through the [[https://docs.computecanada.ca/wiki/Utiliser_des_modules/en][module]] command. You can find the full documentation [[https://lmod.readthedocs.io/en/latest/010_user.html][here]] and below are the subcommands you will need:

#+BEGIN_src sh
# get help on the module command
module help
module --help
module -h

# list modules that are already loaded
module list

# see which modules are available for Julia
module spider julia

# see how to load julia 1.3
module spider julia/1.3.0

# load julia 1.3 with the required gcc module first
# (the order is important)
module load gcc/7.3.0 julia/1.3.0

# you can see that we now have Julia loaded
module list
#+END_src

So the normal process to gain access to Julia version 1.3.0 in the cluster would be to run:
#+BEGIN_src sh
module load gcc/7.3.0 julia/1.3.0
#+END_src

#+BEGIN_export html
We would then install the Julia packages we need. By default, Julia packages are installed in <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.4rem; box-shadow: 0px 0px 3px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">~/.julia</span>.

In order to take a lot of burden out of our training cluster however, since we are all running the same code and using the same packages, instead of each of us installing the packages in our home directories, we will all use packages which have already been installed in <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">/project/shared/bio</span>.

So, for the purpose of this workshop, instead of loading Julia and installing the required packages, we will simply run a little script called <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">/project/shared/syncHPC/startJulia.sh</span>.
#+END_export

Let's see what is in that script:

#+BEGIN_src sh
cat /project/shared/syncHPC/startJulia.sh
#+END_src

As you can see, the script loads the Julia module. The rest sets environment variables to the packages path.

#+BEGIN_challenge
#+BEGIN_export html
<span style="color: #e10070">Challenge</span><br>
Launch Julia, get into the package mode, and make sure the packages we need are installed.
#+END_export
#+END_challenge

*** Job script

We will not run an interactive session with Julia on the cluster: we already have a julia script ready. All we need to do is to write a job script to submit to Slurm, the job scheduler used by the Compute Canada clusters.

#+BEGIN_export html
Save your Slurm job script in the file <span style="font-family: 'Source Code Pro', 'Lucida Console', monospace; font-size: 1.4rem; padding: 0.3rem; box-shadow: 0px 0px 2px rgba(0,0,0,0.3); border-radius: 5%; background-color: #f0f3f3; color: #000000">~/scratch/julia_job/job_script.sh</span>.
#+END_export

In this script, we need:

#+BEGIN_src sh
#!/bin/bash
#SBATCH --job-name=julia		# job name
#SBATCH --time=00:01:00			# max walltime
#SBATCH --mem=100M				# max memory
#SBATCH --output=julia%j.out	# file name for the output
#SBATCH --error=julia%j.err		# file name for errors
# %j gets replaced with the job number

# Normally we would load the necessary modules with:
# module load gcc/7.3.0 julia/1.3.0
# But here we will instead execute the script startJulia.sh:
source /project/shared/syncHPC/startJulia.sh
# This loads the modules and changes environment variables
# so that Julia looks for packages in /project/shared/bio

# Run our Julia script
julia julia_script.jl
#+END_src

Now, we can submit our job to the cluster with:

#+BEGIN_src sh
cd ~/scratch/julia_job
sbatch job_script.sh
#+END_src

And we can check its status with:

#+BEGIN_src sh
sq
#+END_src
