#+title: Plotting
#+description: Practice
#+colordes: #dc7309
#+slug: jl-09-plots
#+weight: 9

{{<br>}}
{{<img src="https://imgs.xkcd.com/comics/coronavirus_charts.png" title="" width="%" line-height="0.5rem">}}
from <a href="https://xkcd.com/">xkcd.com</a>
{{</img>}}

* Load packages

#+BEGIN_src julia
using JLD
using DataFrames
using StatsPlots
using TimeSeries
#+END_src

[[https://github.com/JuliaPlots/Plots.jl][Plots]] is a convenient Julia package which allows to use the same code with many graphing backends such as the [[https://gr-framework.org/][GR framework]] (great for speed), [[https://plotly.com/javascript/][Plotly.js]] (allows interaction with your graphs in a browser), or [[https://matplotlib.org/api/pyplot_api.html][PyPlot]]. [[https://github.com/JuliaPlots/StatsPlots.jl][StatsPlots]] is an enhanced version with added stats functionality.

For this course, we will use the [[https://gr-framework.org/][GR framework]]:

#+BEGIN_src julia
gr()
#+END_src

* Load our data frame

Let's start by loading our data frame from [[https://westgrid-julia.netlify.app/school/jl-08-var.html][the previous lesson]] thanks to the [[https://github.com/JuliaIO/JLD.jl][JLD]] package (of course, use the path to the {{<b>}}covid.jld{{</b>}} file in your system):

#+BEGIN_src julia
datlong = load("../../data/covid.jld", "confirmed")
#+END_src

* World summary

Let's start by plotting a world summary of confirmed Covid-19 cases over time.

For this, we need the sum of confirmed cases for each day. So we group the data by {{<c>}}date{{</c>}} ({{<c>}}:{{</c>}} in {{<c>}}:date{{</c>}} means that {{<c>}}date{{</c>}} is a {{<b>}}Symbol{{</b>}}).

Then we {{<c>}}combine{{</c>}} the data within each group by making the sum of the {{<c>}}confirmed{{</c>}} values and we call our total {{<c>}}confsum{{</c>}}.

#+BEGIN_src julia
world = combine(groupby(datlong, :date), :confirmed => sum => :confsum)
#+END_src

Since our data is a time series, we need to transform the data frame {{<c>}}world{{</c>}} we just created to a {{<b>}}TimeArray{{</b>}} thanks to the {{<c>}}TimeArray{{</c>}} function from the [[https://github.com/JuliaStats/TimeSeries.jl][TimeSeries]] package. Then we can plot it by passing it to the function {{<c>}}plot{{</c>}}:

#+BEGIN_src julia
plot(TimeArray(df1, timestamp = :date))
#+END_src

{{<plotshadow src="/plot/school/covid/world1.png" title="Covid-19 confirmed cases in the world" width="860">}}
Covid-19 confirmed cases in the world
{{</plotshadow>}}

That worked, but our graph is not exactly pretty.

{{<exercise>}}
Looking at the documentation for the <a href="https://docs.juliaplots.org/latest/generated/attributes_plot/">plot</a> and <a href="https://docs.juliaplots.org/latest/generated/attributes_subplot/">subplot</a> attributes of the {{<b>}}Plots{{</b>}} package ({{<b>}}StatsPlots{{</b>}} works the same way), try to customize and improve this graph.<br><br>
For instance, maybe you could give it a title, a better legend, a legend in a better position...
{{</exercise>}}


** Countries/provinces summaries

Now, we want to group the data by country:

#+BEGIN_src julia
countries = groupby(all, :country)
#+END_src

We also need to know how the authors of the dataset decided to label the various countries and their subregions.

For example, if you want to see what the data looks like for France, Canada, and India, you can run:

#+BEGIN_src julia
countries[findall(x -> "France" in x, keys(countries))]
countries[findall(x -> "Canada" in x, keys(countries))]
countries[findall(x -> "India" in x, keys(countries))]
#+END_src

Then you need to subset the data for the countries or provinces you are interested in.

Here are some examples:

#+BEGIN_src julia
# countries for which there are data for several provinces
canada = all[all[:, :country] .== "Canada", :]
us = all[all[:, :country] .== "US", :]
china = all[all[:, :country] .== "China", :]

# countries with no province data
skorea = all[all[:, :country] .== "Korea, South", :]
taiwan = all[all[:, :country] .== "Taiwan*", :]
singapore = all[all[:, :country] .== "Singapore", :]
italy = all[all[:, :country] .== "Italy", :]
spain = all[all[:, :country] .== "Spain", :]

#= countries wich have subregions spread widely in the world;
here, I took the arbitrary decision to only look at the main subregions =#
france = all[all[:, :province] .== "France", :]
uk = all[all[:, :province] .== "United Kingdom", :]

# provinces
bc = all[all[:, :province] .== "British Columbia", :]
ny = all[all[:, :province] .== "New York", :]
#+END_src

Calculate the totals for Canada, US, and China which all have data for subregions:

#+BEGIN_src julia
canada, us, china = by.([canada, us, china], :date,
                        total = :total => sum,
                        dead = :dead => sum,
                        recovered = :recovered => sum,
                        current = :current => sum)
#+END_src

The 3 variables {{<c>}}canada{{</c>}}, {{<c>}}us{{</c>}}, and {{<c>}}china{{</c>}} now only have

In order to

#+BEGIN_src julia
loclist1 = [canada, us, china]
loctitles1 = ["Canada", "US", "China"]

pcanada, pus, pchina =
    map((x, y) -> plot(TimeArray(x, timestamp = :date),
                       title = "$y", legend = :outertopright,
                       widen = :false, dpi = :300),
        loclist1, loctitles1)
#+END_src

On the other hand, the other variables still have the {{<c>}}country{{</c>}} and {{<c>}}province{{</c>}} columns (since we did not group them by countries as we did for {{<c>}}canada{{</c>}}, {{<c>}}us{{</c>}}, and {{<c>}}china{{</c>}} when we calculated the country totals.

So we need to remove those 2 columns before we can pass the DataFrames to {{<c>}}TimeArray(){{</c>}}.

#+BEGIN_src julia
loclist2 = [france, bc, ny, taiwan, skorea, singapore, spain, italy, uk]
loctitles2 = ["France", "BC", "NY", "Taiwan", "South Korea",
              "Singapore", "Spain", "Italy", "UK"]

pfrance, pbc, pny, ptaiwan, pskorea,
psingapore, pspain, pitaly, puk =
    map((x, y) -> plot(TimeArray(select(x, Not([:country, :province])),
                                 timestamp = :date),
                       title = "$y", legend = :outertopright,
                       widen = :false, dpi = :300),
        loclist2, loctitles2)
#+END_src

Now, let's plot a few countries/provinces:

*** North America

#+BEGIN_src julia
plot(pcanada, pbc, pus, pny,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

{{<plotshadow src="/plot/workshop/covid/northamerica1.png" title="Confirmed, dead, recovered, and current in some North American countries/provinces until March 22, 2020" width="860">}}
Data until March 22, 2020
{{</plotshadow>}}

*** Asia

#+BEGIN_src julia
plot(pchina, ptaiwan, pskorea, psingapore,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

{{<plotshadow src="/plot/workshop/covid/asia1.png" title="Confirmed, dead, recovered, and current in some Asian countries until March 22, 2020" width="860">}}
Data until March 22, 2020
{{</plotshadow>}}

*** Europe

#+BEGIN_src julia
plot(pfrance, pspain, pitaly, puk,
     legend = false, titlefontsize = 7, tickfontsize = 6)
#+END_src

{{<plotshadow src="/plot/workshop/covid/europe1.png" title="Confirmed, dead, recovered, and current in some European countries until March 22, 2020" width="860">}}
Data until March 22, 2020
{{</plotshadow>}}

* Data up to the present

** Summary graphs

{{<challenge>}}
Write the code to create an up-to-date graph for the world using the files:<br>
{{<b>}}time_series_covid19_confirmed_global.csv{{</b>}} and {{<b>}}time_series_covid19_deaths_global.csv{{</b>}}.
{{</challenge>}}

Here is the result:

{{<plotshadow src="/plot/workshop/covid/world.png" title="Global confirmed and dead" width="860">}}
Last updated: March 25, 2020
{{</plotshadow>}}

{{<challenge>}}
Create up-to-date graphs for the countries and/or provinces of your choice.
{{</challenge>}}

Here are a few possible results:

{{<plotshadow src="/plot/workshop/covid/4countries.png" title="Confirmed and dead for Italy, Spain, the US, and Canada" width="860">}}
Last updated: March 25, 2020
{{</plotshadow>}}

** Countries comparison

Our side by side graphs don't make comparisons very easy since they vary greatly in their axes scales.

Of course, we could constrain them to have the same axes, but then, why not plot multiple countries or provinces in the same graph?

#+BEGIN_src julia
canada[!, :loc] .= "Canada";
china[!, :loc] .= "China";

all = join(all, canada, china, on = [:date, :total, :dead, :loc],
           kind = :outer)

confirmed = unstack(all[:, collect(3:5)], :loc, :total)

conf_sel = select(confirmed,
                  [:date, :Italy, :Spain, :China, :Iran,
                   :France, :US, Symbol("South Korea"), :Canada])

plot(TimeArray(conf_sel, timestamp = :date),
     title = "Confirmed across a few countries",
     legend = :outertopright, widen = :false)
#+END_src

{{<plotshadow src="/plot/workshop/covid/confirmed.png" title="Number of confirmed cases in a few countries" width="860">}}
Last updated: March 25, 2020
{{</plotshadow>}}

{{<challenge>}}
Write the code to make a similar graph with the number of deaths in a few countries of your choice.
{{</challenge>}}

Here is a possible result:

{{<plotshadow src="/plot/workshop/covid/dead.png" title="Number of deaths in a few countries" width="860">}}
Last updated: March 25, 2020
{{</plotshadow>}}

* Comments & questions
